#!/usr/bin/python3

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2, as
# published by the Free Software Foundation.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

# Variables
CONTENT_PATH = "content"
TARGET_PATH = "output"

# Required imports
import bs4
import jinja2
import json
import markdown
import os
import shutil


def pretty_print(html):
    """
        Returns a cleanly indented version of the provided html code.
    """

    soup = bs4.BeautifulSoup(html)
    return soup.prettify(formatter="html")


def load_json(filename):
    """
        Load the provided JSON file from the content directory.
    """

    with open("%s/%s" % (CONTENT_PATH, filename), "r") as fd:
        return json.loads(fd.read())


def gen_menu(structure, override, prefix):
    """
        Generate a list representing the menu.
        If there are sub-menus, the content of the entry will be a
        nested list.

        The function takes the structure list and an optional override
        dict used to handle translations.

        When all internal links must be prefixed, prefix should be set.
    """

    menu = []
    sub_menu = None
    sub_menu_title = None

    for entry in structure:
        item = dict(entry)

        # Apply the override (if any)
        item.update(override.get(entry['path'], {}))

        if prefix:
            # Prepend the prefix to all internal links
            item['path'] = "%s%s" % (prefix, item['path'])

        if "generator" not in item:
            # Menu splitter
            item['path'] = ""
        elif item['generator'] == "link":
            # External link
            item['path'] = item['meta']['url']

        if len(item['menu']) == 1:
            # Simple menu entry
            menu.append((item['path'],
                         item['menu'][-1]))
        else:
            # Drop-down menu
            if sub_menu_title != item['menu'][0]:
                if sub_menu:
                    menu.append((sub_menu, sub_menu_title))
                sub_menu = []
                sub_menu_title = item['menu'][0]

            sub_menu.append((item['path'],
                             item['menu'][-1]))

    # Process the last drop-down menu
    if structure and sub_menu_title:
        if sub_menu:
            menu.append((sub_menu, sub_menu_title))

    return menu


def gen_pages(structure, override, prefix, **variables):
    for entry in structure:
        item = dict(entry)

        # Apply the override (if any)
        item.update(override.get(entry['path'], {}))

        # Store the original path (required for translations)
        page_raw_path = item['path']

        if prefix:
            # Prepend the prefix to all internal links
            item['path'] = "%s%s" % (prefix, item['path'])

        if "generator" not in item or item['generator'] == "link":
            # Skip the virtual entries (external links, splitters)
            continue

        # Generate the target path and create any missing directory
        output_path = "%s%s/index.html" % (TARGET_PATH, item['path'])
        if not os.path.exists(os.path.dirname(output_path)):
            os.makedirs(os.path.dirname(output_path))

        # Generate the page content
        content = ""
        template = "page.tpl.html"
        if item['generator'] == "html":
            with open("%s/%s" % (CONTENT_PATH,
                                 item['meta']['input']), "r") as fd:
                content = fd.read()
        elif item['generator'] == "markdown":
            with open("%s/%s" % (CONTENT_PATH,
                                 item['meta']['input']), "r") as fd:
                content = markdown.markdown(fd.read())
        elif item['generator'] == "downloads":
            # Support a markdown description before the download table
            if "input" in item['meta']:
                with open("%s/%s" % (CONTENT_PATH,
                                     item['meta']['input']), "r") as fd:
                    content = markdown.markdown(fd.read())

            downloads = []
            for entry in sorted(os.listdir(item['meta']['dir'].lstrip("/")),
                                reverse=True):
                if entry.endswith(".asc"):
                    continue

                fs_path = "%s/%s" % (item['meta']['dir'].lstrip("/"), entry)

                download = {}
                download['filename'] = entry
                download['path'] = "%s/%s" % (item['meta']['dir'], entry)
                download['signame'] = None
                download['sigpath'] = None
                if os.path.exists("%s.asc" % fs_path):
                    download['signame'] = "%s.asc" % download['filename']
                    download['sigpath'] = "%s.asc" % download['path']
                download['size'] = "%sK" % \
                    (round(os.stat(fs_path).st_size / 1024, 2))

                downloads.append(download)

            variables['downloads'] = downloads
            template = "downloads.tpl.html"

        # Pass all the variables to the template and generate the html
        template = env.get_template(template)
        with open(output_path, "w+") as fd:
            fd.write(pretty_print(
                template.render(page_path=item['path'],
                                page_raw_path=page_raw_path,
                                page_title=item['title'],
                                page_menu=item['menu'],
                                content=content,
                                **variables)))


# Load the configuration and structure
env = jinja2.Environment(loader=jinja2.FileSystemLoader('templates/'))
config = load_json("CONFIG.json")
structure = load_json("STRUCTURE.json")

# Wipe the output directory clean
if os.path.exists(TARGET_PATH):
    shutil.rmtree(TARGET_PATH)
os.mkdir(TARGET_PATH)
shutil.copytree("static", "%s/%s" % (TARGET_PATH, "static"))
shutil.copytree("downloads", "%s/%s" % (TARGET_PATH, "downloads"))

# Start generating the website
for lang_code, lang_name in config['languages']:
    # Load a translation override
    override = {}
    try:
        override = {entry['path']: entry
                    for entry in load_json("STRUCTURE.%s.json" % lang_code)}
    except FileNotFoundError:
        pass

    # Figure out the translation prefix
    lang_prefix = ""
    if lang_code:
        lang_prefix = "/%s" % lang_code

    # Generate the menu
    menu = gen_menu(structure, override, lang_prefix)

    # Generate all the pages
    gen_pages(structure, override, lang_prefix,
              menu=menu, page_lang=lang_code,
              languages=config['languages'])
